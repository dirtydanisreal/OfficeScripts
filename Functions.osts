{"version":"0.3.0","body":"function main(workbook: ExcelScript.Workbook) {\n}\n\nfunction computeTargetRange(targetCell: ExcelScript.Range, data: string[][]): ExcelScript.Range {\n    const targetRange = targetCell.getResizedRange(data.length - 1, data[0].length - 1);\n    return targetRange;\n}\n\nfunction borderAround(range: ExcelScript.Range): void {\n    range.getFormat().getRangeBorder(ExcelScript.BorderIndex.edgeLeft).setStyle(ExcelScript.BorderLineStyle.dash);\n    range.getFormat().getRangeBorder(ExcelScript.BorderIndex.edgeRight).setStyle(ExcelScript.BorderLineStyle.dash);\n    range.getFormat().getRangeBorder(ExcelScript.BorderIndex.edgeTop).setStyle(ExcelScript.BorderLineStyle.dash);\n    range.getFormat().getRangeBorder(ExcelScript.BorderIndex.edgeBottom).setStyle(ExcelScript.BorderLineStyle.dash);\n    return;\n}\n\n// Helper function to format date as yyyy-mm-dd\nfunction formatDate(date: Date): string {\n    let year = date.getFullYear();\n    let month = ('0' + (date.getMonth() + 1)).slice(-2);\n    let day = ('0' + date.getDate()).slice(-2);\n    return `${year}-${month}-${day}`;\n}\n\n// Helper function to format time as hh:mm:ss\nfunction formatTime(date: Date): string {\n    let hours = ('0' + date.getHours()).slice(-2);\n    let minutes = ('0' + date.getMinutes()).slice(-2);\n    let seconds = ('0' + date.getSeconds()).slice(-2);\n    return `${hours}:${minutes}:${seconds}`;\n}\n\n function getDataFromSheetWithLoop(dataRange: ExcelScript.Range, selectionCurrentRegion: boolean = false, step:number = 1): (string|number|boolean)[][]{\n  if (selectionCurrentRegion === true){\n    dataRange = dataRange.getSurroundingRegion();\n  }\n  let dataRowCount = dataRange.getRowCount();\n  let dataColCount = dataRange.getColumnCount();\n  let dataRangeVals: (string | number | boolean)[][] = dataRange.getValues();\n  let newRangeVals: (string | number | boolean)[][] = [];\n  let columnCounter = dataColCount / step;\n\n  for (let i = 0; i < dataRowCount; i++) {\n    let tempVals: (string | number | boolean)[] = [];\n    for (let j = 0; j < dataColCount; j += step) {\n      tempVals.push(dataRangeVals[i][j]);\n    }\n    newRangeVals.push(tempVals);\n  }\n  return newRangeVals;\n}\n\nfunction getRowsAndColumnsFromArray(rangeArray: (string | number | boolean)[][]): iRowsAndColumns {\n  let rowsAndColumns: iRowsAndColumns = { rows: 0, columns: 0 };\n  rowsAndColumns.rows = rangeArray.length;\n  rowsAndColumns.columns = rangeArray[0].length;\n  return rowsAndColumns;\n}\n\nfunction getResizedRangeFromArray(inputRange: ExcelScript.Range,rangeValues: (string|number|boolean)[][]): ExcelScript.Range{\n  let rowsAndColumns : iRowsAndColumns = {rows:0,columns:0};\n  rowsAndColumns =  getRowsAndColumnsFromArray(rangeValues);\n  let newRange : ExcelScript.Range = inputRange.getResizedRange(rowsAndColumns.rows-1,rowsAndColumns.columns-1);\n  return newRange;\n}\n\ninterface iRowsAndColumns{\n  rows: number,\n  columns: number\n}\n\n\n/** Uses the excel autofilter based on a column number and an array of strings to filter on */\nfunction applyCustomFilter(\n  sheet: ExcelScript.Worksheet,\n  colIndex: number,\n  values: string[]\n) {\n  sheet.getAutoFilter().apply(sheet.getAutoFilter().getRange(), colIndex, {\n    filterOn: ExcelScript.FilterOn.values,\n    values: values,\n  });\n}\n\n/** After filtering, set visible cells within a given column to a provided value. */\nfunction setVisibleFilteredCells(\n  sheet: ExcelScript.Worksheet,\n  colIndex: number,\n  value: string\n) {\n  const range = sheet\n    .getUsedRange()\n    .getVisibleView()\n    .getRange()\n    .getColumn(colIndex)\n    .getOffsetRange(1, 0)\n    .getResizedRange(-1, 0);\n  range.setValue(value);\n}\n\n/** Copy visible rows from the current sheet to the target sheet. */\nfunction copyVisibleRows(\n  sourceSheet: ExcelScript.Worksheet,\n  targetSheet: ExcelScript.Worksheet\n) {\n  let visibleFilteredCells = sourceSheet.getRange().getVisibleView();\n  targetSheet\n    .getRange(\"A1\")\n    .copyFrom(\n      visibleFilteredCells.getRange(),\n      ExcelScript.RangeCopyType.values\n    );\n}\n\n\n\n/** Get the number of the last used row of the sheet. */\nfunction getLastRowValue(sheet: ExcelScript.Worksheet) {\n  const addressMatch = sheet\n    .getUsedRange()\n    .getLastRow()\n    .getAddress()\n    .match(\"![A-Z](.*):\");\n  return addressMatch ? addressMatch[1] : null;\n}\n\n\n/** Get all the column labels as an array. */\nfunction getColLabels(sheet: ExcelScript.Worksheet) {\n  return sheet.getUsedRange().getRow(0).getValues()[0];\n}\n\nfunction addRow(sheet: ExcelScript.Worksheet, data: (string | number | boolean)[]): void {\n\n    const usedRange = sheet.getUsedRange();\n    let startCell: ExcelScript.Range;\n    // IF the sheet is empty, then use A1 as starting cell for update\n    if (usedRange) { \n      startCell = usedRange.getLastRow().getCell(0, 0).getOffsetRange(1, 0);\n    } else {\n      startCell = sheet.getRange('A1');\n    }\n    console.log(startCell.getAddress());\n    const targetRange = startCell.getResizedRange(0, data.length - 1);      \n    targetRange.setValues([data]);\n    return;\n}\n\nfunction sleepy(seconds: number): void {\n  const waitUntil: number = new Date().getTime() + seconds * 1000;\n  while (new Date().getTime() < waitUntil) { }\n}\n\nfunction getOrCreateWorksheet(workbook: ExcelScript.Workbook, sheetName: string): ExcelScript.Worksheet {\n  let sheet = workbook.getWorksheet(sheetName);\n  if (!sheet) {\n    sheet = workbook.addWorksheet(sheetName);\n  }\n  return sheet;\n}\n\nfunction getUsedRange(workbook: ExcelScript.Workbook, sheetName: string): ExcelScript.Range | null {\n  const sheet = workbook.getWorksheet(sheetName);\n  return sheet ? sheet.getUsedRange() : null;\n}\n\nfunction clearRange(workbook: ExcelScript.Workbook, sheetName: string, rangeAddress: string): void {\n  const sheet = workbook.getWorksheet(sheetName);\n  if (sheet) {\n    const range = sheet.getRange(rangeAddress);\n    range.clear(ExcelScript.ClearApplyTo.contents);\n  }\n}\n\nfunction writeData(workbook: ExcelScript.Workbook, sheetName: string, rangeAddress: string, data: (string | number)[][]): void {\n  const sheet = workbook.getWorksheet(sheetName);\n  if (sheet) {\n    const range = sheet.getRange(rangeAddress);\n    range.setValues(data);\n  }\n}\n\nfunction appendDataToTable(workbook: ExcelScript.Workbook, sheetName: string, tableName: string, data: (string | number)[][]): void {\n  const sheet = workbook.getWorksheet(sheetName);\n  if (sheet) {\n    const table = sheet.getTable(tableName);\n    if (table) {\n      table.addRows(-1, data);\n    }\n  }\n}\n\nfunction findAndReplace(\n  workbook: ExcelScript.Workbook,\n  sheetName: string,\n  rangeAddress: string,\n  findText: string,\n  replaceText: string,\n  caseSensitive: boolean = false\n): void {\n  const sheet = workbook.getWorksheet(sheetName);\n  if (sheet) {\n    const range = sheet.getRange(rangeAddress);\n\n    // Create the ReplaceCriteria object\n    const replaceCriteria: ExcelScript.ReplaceCriteria = {\n      completeMatch: false,\n      matchCase: caseSensitive\n    };\n\n    // Call replaceAll with ReplaceCriteria\n    range.replaceAll(findText, replaceText, replaceCriteria);\n  }\n}\n\n\n\nfunction autoFitColumns(workbook: ExcelScript.Workbook, sheetName: string, rangeAddress: string): void {\n  const sheet = workbook.getWorksheet(sheetName);\n  if (sheet) {\n    const range = sheet.getRange(rangeAddress);\n    range.getFormat().autofitColumns();\n  }\n}\n\nfunction sortRange(workbook: ExcelScript.Workbook, sheetName: string, rangeAddress: string, sortColumnIndex: number, ascending: boolean = true): void {\n  const sheet = workbook.getWorksheet(sheetName);\n  if (sheet) {\n    const range = sheet.getRange(rangeAddress);\n    range.getSort().apply([{ key: sortColumnIndex, ascending: ascending }]);\n  }\n}\n\nfunction convertRangeToTable(workbook: ExcelScript.Workbook, sheetName: string, rangeAddress: string, tableName: string): ExcelScript.Table | null {\n  const sheet = workbook.getWorksheet(sheetName);\n  if (sheet) {\n    const range = sheet.getRange(rangeAddress);\n    const table = sheet.addTable(range, true);\n    table.setName(tableName);\n    return table;\n  }\n  return null;\n}\n\nfunction applyCellValueConditionalFormatting(\n  workbook: ExcelScript.Workbook,\n  sheetName: string,\n  rangeAddress: string,\n  comparisonOperator: ExcelScript.ConditionalCellValueOperator,\n  comparisonValue: string,\n  color: string = \"#FFCCCB\"\n): void {\n  const sheet = workbook.getWorksheet(sheetName);\n  if (sheet) {\n    const range = sheet.getRange(rangeAddress);\n\n    // Add conditional formatting of type cellValue\n    const conditionalFormat = range.addConditionalFormat(ExcelScript.ConditionalFormatType.cellValue);\n\n    // Set the cell value rule with the specified comparison operator and value\n    conditionalFormat.getCellValue().setRule({\n      formula1: comparisonValue,\n      operator: comparisonOperator\n    });\n\n    // Set the fill color for cells that match the rule\n    conditionalFormat.getCustom().getFormat().getFill().setColor(color);\n  }\n}\n\n\nfunction getUniqueValues(\n  workbook: ExcelScript.Workbook,\n  sheetName: string,\n  columnAddress: string\n): (string | number | boolean)[] {\n  const sheet = workbook.getWorksheet(sheetName);\n  const range = sheet.getRange(columnAddress);\n\n  // Explicitly define the type for values as a 2D array of strings, numbers, or booleans\n  const values: (string | number | boolean)[][] = range.getValues();\n\n  // Flatten the two-dimensional array manually to get a one-dimensional array\n  const flattenedValues: (string | number | boolean)[] = [];\n  for (let i = 0; i < values.length; i++) {\n    flattenedValues.push(values[i][0]); // Only take the first element of each row\n  }\n\n  // Use Set to get unique values\n  const uniqueValues = Array.from(new Set(flattenedValues));\n  return uniqueValues;\n}\n\n\n\nfunction getCurrentDate(format: \"MM/DD/YYYY\" | \"YYYY-MM-DD\" = \"MM/DD/YYYY\"): string {\n  const now = new Date();\n  const year = now.getFullYear();\n  const month = String(now.getMonth() + 1).padStart(2, '0');\n  const day = String(now.getDate()).padStart(2, '0');\n\n  return format === \"MM/DD/YYYY\" ? `${month}/${day}/${year}` : `${year}-${month}-${day}`;\n}\n\nfunction insertDate(\n  workbook: ExcelScript.Workbook,\n  sheetName: string,\n  cellAddress: string,\n  format: \"MM/DD/YYYY\" | \"YYYY-MM-DD\" = \"MM/DD/YYYY\"\n): void {\n  const sheet = workbook.getWorksheet(sheetName);\n  if (sheet) {\n    const range = sheet.getRange(cellAddress);\n    range.setValue(getCurrentDate(format));\n  }\n}\n\nfunction filterRangeByValue(\n  workbook: ExcelScript.Workbook,\n  sheetName: string,\n  rangeAddress: string,\n  columnIndex: number,\n  filterValue: string | number\n): void {\n  const sheet = workbook.getWorksheet(sheetName);\n  if (sheet) {\n    const range = sheet.getRange(rangeAddress);\n    const table = sheet.addTable(range, true);\n    table.getAutoFilter().apply(range);\n    table.getColumn(columnIndex).getFilter().applyValuesFilter([filterValue]);\n  }\n}\n\nfunction calculateSum(\n  workbook: ExcelScript.Workbook,\n  sheetName: string,\n  rangeAddress: string\n): number {\n  const sheet = workbook.getWorksheet(sheetName);\n  const range = sheet.getRange(rangeAddress);\n  const values = range.getValues().flat();\n\n  // Calculate the sum\n  const sum = values.reduce((acc, val) => (typeof val === \"number\" ? acc + val : acc), 0);\n  return sum;\n}\n\nfunction highlightDuplicates(\n  workbook: ExcelScript.Workbook,\n  sheetName: string,\n  rangeAddress: string,\n  color: string = \"#FFA07A\"\n): void {\n  const sheet = workbook.getWorksheet(sheetName);\n  const range = sheet.getRange(rangeAddress);\n\n  // Define the starting cell for the helper column (assumes it's the next column to the range)\n  const helperColumnStart = range.getOffsetRange(0, range.getColumnCount());\n  const helperColumnAddress = helperColumnStart.getColumnIndex();\n\n  // Fill the helper column with a formula to detect duplicates in the specified range\n  const rowCount = range.getRowCount();\n  for (let i = 0; i < rowCount; i++) {\n    const cell = helperColumnStart.getCell(i, 0);\n    const formula = `=COUNTIF(${rangeAddress}, ${range.getCell(i, 0).getAddress()}) > 1`;\n    cell.setFormula(formula);\n  }\n\n  // Apply conditional formatting based on the helper column\n  const conditionalRange = range.getFormat();\n  for (let i = 0; i < rowCount; i++) {\n    const conditionCell = range.getCell(i, 0).getFormat();\n    const helperValue = helperColumnStart.getCell(i, 0).getValue() as boolean;\n\n    // If the helper column value is true, apply the duplicate color formatting\n    if (helperValue) {\n      conditionCell.getFill().setColor(color);\n    }\n  }\n}\n\n/**\n * Clears all existing allowToEdit settings and then sets new allowToEdit ranges.\n *\n * @param workbook The workbook object in the Excel script.\n * @param editableRanges An array of string ranges that should be editable, e.g., [\"A1:C10\", \"D1:D10\"]\n */\nfunction clearAndSetAllowEdit(workbook: ExcelScript.Workbook, editableRanges: string[]) {\n  // Select the active sheet (you can change this to a specific sheet name if needed)\n  let sheet = workbook.getActiveWorksheet();\n\n  // Clear all existing allowEdit permissions by unprotecting the sheet\n  let protection = sheet.getProtection();\n  if (protection.getProtected()) {\n    protection.unprotect();\n  }\n\n  // Protect the sheet to apply new settings\n  protection.protect();\n\n  // Loop through the specified ranges and set them as editable\n  editableRanges.forEach(rangeAddress => {\n    let range = sheet.getRange(rangeAddress);\n    range.getFormat().getProtection().setLocked(false);\n  });\n\n  // Log completion\n  console.log(\"Protection settings updated. Specified ranges are now editable.\");\n}\n\n/**\n * Check if a target range is fully within an allowed range.\n * @param targetRange The target range for pasting\n * @param allowedRange The allowed range\n * @returns True if the target range is within the allowed range\n */\nfunction isRangeWithin(targetRange: ExcelScript.Range, allowedRange: ExcelScript.Range): boolean {\n\tconst targetAddress = targetRange.getAddress();\n\tconst allowedAddress = allowedRange.getAddress();\n\n\tconst [targetSheet, targetRangeOnly] = targetAddress.split(\"!\");\n\tconst [allowedSheet, allowedRangeOnly] = allowedAddress.split(\"!\");\n\n\t// Ensure ranges are on the same sheet\n\tif (targetSheet !== allowedSheet) {\n\t\treturn false;\n\t}\n\n\t// Extract range boundaries\n\tconst targetBoundaries = getRangeBoundaries(targetRangeOnly);\n\tconst allowedBoundaries = getRangeBoundaries(allowedRangeOnly);\n\n\t// Check if target boundaries are within allowed boundaries\n\treturn (\n\t\ttargetBoundaries.startRow >= allowedBoundaries.startRow &&\n\t\ttargetBoundaries.endRow <= allowedBoundaries.endRow &&\n\t\ttargetBoundaries.startColumn >= allowedBoundaries.startColumn &&\n\t\ttargetBoundaries.endColumn <= allowedBoundaries.endColumn\n\t);\n}\n\n/**\n * Get range boundaries from a range address (e.g., \"A1:B10\").\n * @param rangeAddress The range address as a string\n * @returns An object with start and end row/column\n */\nfunction getRangeBoundaries(rangeAddress: string): { startRow: number; endRow: number; startColumn: number; endColumn: number } {\n\tconst rangeMatch = /([A-Z]+)(\\d+):([A-Z]+)(\\d+)/.exec(rangeAddress);\n\tif (!rangeMatch) {\n\t\tthrow new Error(`Invalid range address: ${rangeAddress}`);\n\t}\n\n\tconst [, startCol, startRow, endCol, endRow] = rangeMatch;\n\n\treturn {\n\t\tstartRow: parseInt(startRow),\n\t\tendRow: parseInt(endRow),\n\t\tstartColumn: columnLetterToNumber(startCol),\n\t\tendColumn: columnLetterToNumber(endCol),\n\t};\n}\n\n/**\n * Convert a column letter (e.g., \"A\", \"B\", \"AA\") to a column number.\n * @param columnLetter The column letter\n * @returns The column number\n */\nfunction columnLetterToNumber(columnLetter: string): number {\n\tlet column = 0;\n\tfor (let i = 0; i < columnLetter.length; i++) {\n\t\tcolumn = column * 26 + (columnLetter.charCodeAt(i) - \"A\".charCodeAt(0) + 1);\n\t}\n\treturn column;\n}\n\nfunction setCurrentDate(worksheet: ExcelScript.Worksheet, cell: ExcelScript.Range) {\n\n  let date = new Date(Date.now());\n\n  cell.setValue(date.toLocaleDateString());\n\n}\n\nfunction formatCellRange(myRange: ExcelScript.Range) {\n  /* Clear formats from range (just in case there is formatting applied other than what is being specified here.) \n  This also clears out any manually-selected cell fill/highlighting \n    https://docs.microsoft.com/en-us/office/dev/add-ins/excel/excel-add-ins-ranges-set-get-values\n    https://docs.microsoft.com/en-us/javascript/api/office-scripts/excelscript/excelscript.rangeformat?view=office-scripts\n    https://docs.microsoft.com/en-us/javascript/api/office-scripts/excelscript/excelscript.verticalalignment?view=office-scripts */\n  myRange.clear(ExcelScript.ClearApplyTo.formats);\n\n  // Set vertical alignment to ExcelScript.VerticalAlignment.center for myRange on selectedSheet\n  myRange.getFormat().setVerticalAlignment(ExcelScript.VerticalAlignment.center);\n  myRange.getFormat().setIndentLevel(0);\n  // Set horizontal alignment to ExcelScript.HorizontalAlignment.left for range N61 on selectedSheet\n  myRange.getFormat().setHorizontalAlignment(ExcelScript.HorizontalAlignment.left);\n\n  // Set font name to \"Consolas\" for myRange on selectedSheet\n  myRange.getFormat().getFont().setName(\"Consolas\");\n  // Set font size to 10 for myRange on selectedSheet\n  myRange.getFormat().getFont().setSize(10);\n};","description":"","noCodeMetadata":"","parameterInfo":"{\"version\":1,\"originalParameterOrder\":[],\"parameterSchema\":{\"type\":\"object\",\"default\":{},\"x-ms-visibility\":\"internal\"},\"returnSchema\":{\"type\":\"object\",\"properties\":{}},\"signature\":{\"comment\":\"\",\"parameters\":[{\"name\":\"workbook\",\"comment\":\"\"}]}}","apiInfo":"{\"variant\":\"synchronous\",\"variantVersion\":2}"}